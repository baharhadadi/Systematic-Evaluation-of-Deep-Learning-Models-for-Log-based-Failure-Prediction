"""
This file contains functions for guided random walk that are going to be used in run() method of DataGenerator class
in data_generator.py
"""
import random
import re
import exrex


# boolean function to check if the stop condition for data generation is meet or not
# mask is a list to check if all the failure states are visited during data generation or not
def stop_condition(dataset, failure_perc, mask, min_size, max_size):
    if not dataset:  # the dataset is empty
        return False

    if len(dataset) >= max_size:  # if the dataset size exceed the limit
        return True

    labels = [l for _, l in dataset]  # contains the label of generated sequences to check the percentage of failure
    # sequences
    current_failure_perc = (sum([1 for l in labels if l == 'failure']) / len(labels)) * 100

    if abs(failure_perc - current_failure_perc) < 0.1:
        if 0 not in mask.values():  # if all the failure states are visited
            if len(dataset) > min_size:  # if the minimum dataset size is met
                return True
    return False


# generates failure sequences based on the input failure pattern which is a regular expression
def generate_failure_sequence(failure_pattern, min_length, max_length, size):
    # omit whitespaces in regular expression
    failure_pattern = failure_pattern.replace(' ', '')

    # check if the language has member with length equal or smaller than maximum length
    failure_pattern_without_star = failure_pattern.replace('*', '{0,1}')

    # generate the shortest sequences of pattern
    sequences = set(exrex.generate(failure_pattern_without_star))
    # calculate their length
    lengths = [len(tuple(s.split(','))) for s in sequences]
    # if the minimum length of an accepted sequence is still bigger than maximum length
    # then no member of the failure pattern will be within the desired range length
    # so it returns empty list
    if min(lengths) > max_length:
        return []

    # now if there is at least one member of the language within the desired range
    generated_sequences = []  # store the generated sequences within desired range of length
    k = 50  # argument value for getone method that had relation with length of sequence (k = 50 can loop a kleene
    # star more than 3000 time)

    # if the size is bigger than 500, 
    # experimentally with respect to the factor values, the value of 500 is enough to have variaty of the log sequences
    if size > 500:
      size = 500

    while k > 0:
        for _ in range(size):
            # randomly generate a seqeunce
            sequence = tuple(exrex.getone(failure_pattern, limit=k).split(','))
            # if its in accepted range of length and not empty added to the list of generated sequences
            if max_length >= len(sequence) >= min_length and sequence != (''):
                generated_sequences.append(sequence)
        # decrease the k to get more variety of generated sequence within desired range
        k -= 1

    # omit the replicated sequences
    options = list(set(generated_sequences))

    return options


# check if the input sequence can be generated by the input automaton
def is_valid_sequence(automaton, sequence):
    # start the walk from initial state
    current_state = automaton.initial_state

    # k stores index of the element from sequence that is going to be read during walk
    k = 0

    # while there is element left to be read by the walk
    while k < len(sequence):

        # boolean variable to check if next element has been read in walk or not
        update = False

        for key, value in automaton.transitions.items():
            if key[0] == current_state:
                # if the next element is in the possible transitions of current state
                if key[1] == sequence[k]:
                    # go to the next state
                    current_state = value
                    # go to the next element of the sequence
                    k += 1
                    # update is True now
                    update = True
                    break
        # if k-th element of the sequence wasn't found during walk
        # then the sequence is invalid
        if not update:
            return False
    # if the walk reached to terminal state by reading the input sequence
    # then return true as valid
    # here both acceptance and sink states are counted
    if current_state in automaton.terminal_states:
        return True
    return False


# filtered random walk that generate one sequence with respect to the mode of data generation (normal/failure)
def filtered_random_walk(automaton, mlsl, long_sequence=False):
    sequence = []  # stores the generated sequence through random walk
    current_state = automaton.initial_state

    sequence_size_counter = mlsl

    while current_state not in automaton.accepting_states:

        options = set()
        s = 0
        for t in automaton.next_transitions[current_state]:
                # filtering
                if automaton.s_values[t[0]] <= sequence_size_counter:
                    options.add(t)
                    s += automaton.s_values[t[0]]

        # random choose from the options
        if len(list(options)) == 0:
            print(sequence, sequence_size_counter, current_state)

        if not long_sequence:
            next_move = random.choice(list(options))
        else:
            if s == 0:
                next_move = random.choice(list(options))
            else:
                next_move = random.choices(list(options),
                                           weights=[automaton.s_values[state] / s for state, logtemplate in
                                                    list(options)], k=1)[0]

        # walk to the next state and read the transition log template ID
        sequence.append(next_move[1])
        current_state = next_move[0]
        sequence_size_counter -= 1

    return tuple(sequence), '-1'


# check if a sequence belongs to failure category
def is_failure_sequence(sequence, automaton):
    # convert tuple object to string that log template IDs are divided by ','
    sequence = ','.join(list(sequence))

    # for each regular expression in failure pattern set of the automata
    for pattern in automaton.failure_patterns:
        # check if the sequence match with the pattern
        if re.match(pattern, sequence):
            return True
    return False
